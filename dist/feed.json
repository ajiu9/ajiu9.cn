{
    "version": "https://jsonfeed.org/version/1",
    "title": "Ajiu9",
    "home_page_url": "https://ajiu9.cn/",
    "feed_url": "https://ajiu9.cn/feed.json",
    "description": "Ajiu9' Blog",
    "icon": "https://ajiu9.cn/avatar.png",
    "author": {
        "name": "Ajiu9",
        "url": "https://ajiu9.cn"
    },
    "items": [
        {
            "content_html": "<p>如何在浏览器中打印页面内容？</p>\n<p>通过iframe调用window.print打印</p>\n<ol>\n<li>创建一个隐藏的iframe</li>\n<li>通过iframe的contentWindow属性获取iframe的window对象，然后调用window.print()方法</li>\n</ol>\n<p>iframe 通过设置style为display:none，position:absolute，width:0px，height:0px，left:-500px，top:-500px，这样可以隐藏iframe，但是不影响页面的布局。</p>\n<p>注意： 如果有写入图片，因为是异步，需要在下一个宏任务中执行。</p>\n<p>下面是一段代码：</p>\n<pre><code class=\"language-js\">function print(content) {\n  let iframe = document.body.querySelector('#window-print')\n  if (!iframe) {\n    iframe = document.createElement('iframe')\n    iframe.id = 'window-print'\n    iframe.setAttribute('style', 'display:none;position:absolute;width:0px;height:0px;left:-500px;top:-500px;')\n    document.body.appendChild(iframe)\n  }\n  const printDocument = iframe.contentWindow.document\n  printDocument.write(content)\n  printDocument.close()\n  iframe.contentWindow.focus()\n  setTimeout(() =&gt; {\n    iframe.contentWindow.print()\n  }, 0)\n}\n</code></pre>\n<p>打印效果：<br>\n<img src=\"https://static.ajiu9.cn/images/20240310203634jdJVNW.png\" alt=\"\"></p>\n<p>该方法的优点是可以在不离开当前页面的情况下实现打印功能，且可以对打印的页面进行一些自定义设置，比如隐藏一些元素或者设置页面样式等。</p>\n<p>使用该方法需要注意的是，由于涉及到跨域访问的问题，可能存在一些安全性和兼容性的问题，需要进行适当的测试和处理。</p>\n",
            "url": "https://ajiu9.cn/posts/window-print",
            "title": "在浏览器中实现页面打印",
            "date_modified": "2024-03-09T00:00:00.000Z",
            "author": {
                "name": "Ajiu9",
                "url": "https://ajiu9.cn"
            }
        },
        {
            "content_html": "<blockquote>\n<p>我的电脑重装了系统，重新梳理了下软件和工具，以及配置，用了大概5个小时，使用起来爽多了</p>\n</blockquote>\n<h3>安装clashX</h3>\n<h3>安装APP和Cli工具</h3>\n<ol>\n<li>安装HomeBrew 并用它安装app和cli工具。App 可以在homebrew-cask — Homebrew Formulae里找有没有，Cli 工具可以在homebrew-core — Homebrew Formulae 找有没有。</li>\n</ol>\n<pre><code class=\"language-bash\"># 先开代理\nexport https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890\n\n# 安装 HomeBrew\n/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;\n\n# 用 HomeBrew 安装 App，以下是我可以用 HomeBrew 安装的 App 列表\nbrew install --cask  battery-buddy  espanso google-chrome gas-mask obsidian visual-studio-code Paycast Picsee\n\n# 安装 Cli 工具\nbrew install autojump diff-so-fancy  fd gh git nvm pnpm tree\n</code></pre>\n<ol>\n<li>用 Mac App Store 安装额外 App。</li>\n</ol>\n<ul>\n<li>Bob</li>\n<li>RunCat</li>\n<li>Influse</li>\n</ul>\n<h3>准本本地目录</h3>\n<p>在 ~/Documents 下建目录Code, SoftwareConfigurationCode和Notes。（后续添加更多）Code用于存代码；SoftwareConfiguration 用于保存各种软件配置，把 Espanso 等的配置放在这里。</p>\n<h3>配置App</h3>\n<ol>\n<li>\n<p>Karabiner-Elements<br>\n参考 Karabiner-Element 配置 F19 键 - HackMD 。在 Karabiner-Elements complex_modifications rules 搜「Change caps_lock key」，import 后只保留一条和 F19 相关的，然后在命令行里编辑「~/.config/karabiner/karabiner.json」，把刚才那条规则的「caps_lock」换成「right_command」（两处）。这样你就把基本不会用到的「右⌘」废物利用变成了「F19」键，然后你的快捷键组合会多很多。</p>\n<p>如果你仔细看配置，会发现「F19」是由四个键「⌘⇧⌃⌥」组成的，在一些 App 的快捷键配置里你会看到四个键，不要奇怪，这也是他。</p>\n</li>\n<li>\n<p>Raycast<br>\n快捷键操作集成窗口，超级好用，用来组合F19可以玩出很多花样</p>\n</li>\n<li>\n<p>zsh<br>\n安装 zsh 和 starship，starship 是 rust 写的 prompt 工具，极快</p>\n</li>\n</ol>\n<pre><code class=\"language-bash\">brew install starshipecho 'eval &quot;$(starship init zsh)&quot;' &gt;&gt; ~/.zshrc\n</code></pre>\n<p>安装 zsh 的插件 zsh-autosuggestions、zsh-completions 和 fast-syntax-highlighting。</p>\n<pre><code class=\"language-bash\">git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-$HOME/Documents/SoftwareConfiguration/zsh}/zsh-autosuggestionsgit ÏÏÏclone https://github.com/zsh-users/zsh-completions ${ZSH_CUSTOM:-$HOME/Documents/SoftwareConfiguration/zsh}/zsh-completionsgit clone https://github.com/zdharma-continuum/fast-syntax-highlighting.git ${ZSH_CUSTOM:-$HOME/Documents/SoftwareConfiguration/zsh}/fast-syntax-highlighting\n</code></pre>\n<pre><code class=\"language-bash\">export HOMEBREW_NO_AUTO_UPDATE=1\n\n# Alias\nalias ip=&quot;ipconfig getifaddr en0&quot;\nalias sshconfig=&quot;vim ~/.ssh/config&quot;\nalias gitconfig=&quot;vim ~/.gitconfig&quot;\n\n# chore\nalias br=&quot;bun run&quot;\nalias c='code .'\nalias pi=&quot;echo 'Pinging Baidu' &amp;&amp; ping www.baidu.com&quot;\nalias ip=&quot;ipconfig getifaddr en0 &amp;&amp; ipconfig getifaddr en1&quot;\nalias cip=&quot;curl cip.cc&quot;\nalias hosts=&quot;vi /etc/hosts&quot;\nalias cdtemp=&quot;cd `mktemp -d /tmp/ajiu9-XXXXXX`&quot;\n\nfunction grandom() {\n  # 获取当前日期\n  current_date=$(date &quot;+%Y-%m-%d&quot;)\n  # 生成4个随机数字\n  random_number=$(( RANDOM % 676 ))\n  # 将随机数转换为A-Z随机字符\n  random_chars=&quot;&quot;\n  for (( i=0; i&lt;4; i++)); do\n    random_char_index=$(( RANDOM % 26 ))\n    random_char=$(printf \\\\$(printf '%03o' $((65 + random_char_index))))\n    random_chars=&quot;${random_chars}${random_char}&quot;\n  done\n  # 格式化为指定格式的字符串\n  formatted_string=&quot;${current_date}-${random_chars}&quot;\n  if [[ -n $1 ]]; then\n    echo `git checkout -b &quot;$1&quot;/ajiu9-&quot;$formatted_string&quot;`\n  else\n    echo `git checkout -b ajiu9-&quot;$formatted_string&quot;`\n  fi\n}\n\n## system\nalias showFiles=&quot;defaults write com.apple.finder AppleShowAllFiles YES &amp;&amp; killall Finder&quot;\nalias hideFiles=&quot;defaults write com.apple.finder AppleShowAllFiles NO &amp;&amp; killall Finder&quot;\n\n# cd\nalias ..='cd ../'\nalias ...='cd ../../'\nalias ..l.='cd ../../ &amp;&amp; ll'\nalias ....='cd ../../../'\nalias ~=&quot;cd ~&quot;\nalias -- -=&quot;cd -&quot;\nalias ll=&quot;ls -alhG&quot;\nalias ls=&quot;ls -G&quot;\n\n# git\nalias gps=&quot;git push&quot;\nalias gpl=&quot;git pull&quot;\nalias gt=&quot;git status -sb&quot;\nalias ga=&quot;git add .&quot;\nalias gc=&quot;git commit -av&quot;\nalias gcr=&quot;git checkout master &amp;&amp; git fetch &amp;&amp; git rebase&quot;\nalias gclean=&quot;git reset --hard &amp;&amp; git clean -df&quot;\nalias grebase=&quot;git fetch &amp;&amp; git rebase -i&quot;\nalias glg=&quot;git log --pretty='%C(red)%h%Creset%C(yellow)%d%Creset %s %C(cyan)(%ar)%Creset'&quot;\nalias gdel=&quot;git branch --merged master | egrep -v '(\\*|master|release|bug$|dev)' | xargs -n 1 -r git branch -d&quot;\nalias gck=&quot;git checkout&quot;\nfunction gb() {\n  echo `git checkout &quot;$1&quot; &amp;&amp; git pull &amp;&amp; git checkout -b &quot;$2&quot;`\n}\n\nfunction record() {\ncd ~/screencapture/jpg;\nRES_WIDTH=$(/usr/sbin/system_profiler SPDisplaysDataType | grep Resolution);\nRES_WIDTH=(${RES_WIDTH:22:4});\nRES_WIDTH=$((RES_WIDTH/2));\nwhile :\nNOW=$(date +&quot;%y%m%d%H%M%S&quot;);\ndo screencapture -C -t jpg -x ~/screencapture/jpg/$NOW.jpg;\nsleep 7 &amp; pid=$!\nNOW=$(date +&quot;%y%m%d%H%M%S&quot;);\nwait $pid\ndone\n}\n\nfunction movie() {\nNOW=$(date +&quot;%y%m%d%H%M%S&quot;);\ncd ~/screencapture/jpg;\ncnt=0\nrm -rf .DS_Store;\nfor file in *\ndo\nif [ -f &quot;$file&quot; ] ; then\next=${file##*.}\nprintf -v pad &quot;%05d&quot; &quot;$cnt&quot;\nmv &quot;$file&quot; &quot;${pad}.${ext}&quot;\ncnt=$(( $cnt + 1 ))\nfi\ndone;\nrm -rf 00000.jpg;\nfor pic in *.jpg;\ndo convert $pic -resize 50% $pic;\ndone;\nffmpeg -r 24 -i %05d.jpg -b 20000k ~/screencapture/mov/$USER-$NOW.mov;\nrm -rf ./*.jpg;\n}\n\nfunction mcd {\nmkdir $1 &amp;&amp; cd $1;\n}\n\nfunction pfd() {\n\nosascript 2&gt;/dev/null &lt;&lt;EOF\n\ntell application &quot;Finder&quot;\n\nreturn POSIX path of (target of window 1 as alias)\n\nend tell\n\nEOF\n\n}\n\nfunction cdf() {\ncd &quot;$(pfd)&quot;\n}\n\nfunction ,touch {\nmkdir -p &quot;$(dirname &quot;$1&quot;)&quot; &amp;&amp; touch &quot;$1&quot;\n}\n\nfunction ,take() {\nmkdir -p &quot;$(dirname &quot;$1&quot;)&quot; &amp;&amp; touch &quot;$1&quot; &amp;&amp; take &quot;$(dirname &quot;$1&quot;)&quot;\n}\n\n# load zsh-completions\nautoload -U compinit &amp;&amp; compinit\nsource ~/Documents/SoftwareConfiguration/zsh/zsh-autosuggestions/zsh-autosuggestions.zsh\nsource ~/Documents/SoftwareConfiguration/zsh/zsh-completions/zsh-completions.plugin.zsh\nsource ~/Documents/SoftwareConfiguration/zsh/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh\nsource ~/.bash_profile\n\n[ -f &quot;/usr/local/etc/profile.d/autojump.sh&quot; ] &amp;&amp; . &quot;/usr/local/etc/profile.d/autojump.sh&quot; # This loads autojump\n\n# bun completions\n[ -s &quot;/Users/wulongbiao/.bun/_bun&quot; ] &amp;&amp; source &quot;/Users/wulongbiao/.bun/_bun&quot;\n\n# bun\nexport BUN_INSTALL=&quot;$HOME/.bun&quot;\nexport PATH=&quot;$BUN_INSTALL/bin:$PATH&quot;\nexport HOMEBREW_BOTTLE_DOMAIN=https://mirrors.aliyun.com/homebrew/homebrew-bottles\n# pnpm\nexport PNPM_HOME=&quot;/Users/wulongbiao/Library/pnpm&quot;\nexport PATH=&quot;$PNPM_HOME:$PATH&quot;\n\n# use starship theme (needs to be at the end)\neval &quot;$(starship init zsh)&quot;\n</code></pre>\n<ol start=\"4\">\n<li>额外的命令行工具：Bun 和 Projj</li>\n</ol>\n<p>安装 Bun。主要是用他的 run 命令，极快，上面也有别名 <code>br</code>，比如执行比如 <code>br dev</code> 即 <code>npm run dev</code>。</p>\n<pre><code>curl -fsSL https://bun.sh/install | bash\n</code></pre>\n<p>安装 PROJJ，用他来管理 Code 下的仓库，按「domain/group/repo」这样组织，找起来会比较容易。</p>\n<pre><code class=\"language-bash\">pnpm i projj projj-hooks -g\nprojj init\n</code></pre>\n<ol start=\"5\">\n<li>然后编辑 ~/.projj/config.json</li>\n</ol>\n<pre><code class=\"language-json\">{\n  &quot;base&quot;: [\n    &quot;/Users/wulongbiao/Documents/Code&quot;\n  ],\n  &quot;hooks&quot;: {\n    &quot;postadd&quot;: &quot;projj_git_config_user&quot;,\n    &quot;clean&quot;: &quot;clean&quot;\n  },\n\n  &quot;postadd&quot;: {\n    &quot;github.com&quot;: {\n      &quot;name&quot;: &quot;ajiu9&quot;,\n      &quot;email&quot;: &quot;615944323@qq.com&quot;\n    }\n  },\n  &quot;alias&quot;: {\n    &quot;github://&quot;: &quot;https://github.com/&quot;\n  }\n}\n</code></pre>\n<p>然后就可以愉快地用 PROJJ 添加项目了，比如。</p>\n<pre><code class=\"language-bash\">projj add git@github.com:ajiu9/eslint-config.git\n</code></pre>\n<ol start=\"6\">\n<li>Espanso<br>\n在 ~/Documents/SoftwareConfiguration/Espanso 下建了个 base.yml，并软链到 Espanso 原来的配置文件夹里。</li>\n</ol>\n<pre><code class=\"language-yml\"># espanso match file\n# For a complete introduction, visit the official docs at: https://espanso.org/docs/\n# You can use this file to define the base matches (aka snippets)\n# that will be available in every application when using espanso.\n# Matches are substitution rules: when you type the &quot;trigger&quot; string\n# it gets replaced by the &quot;replace&quot; string.\nmatches:\n  # Simple text replacement\n  # NOTE: espanso uses YAML to define matches, so pay attention to the indentation!\n  # But matches can also be dynamic:\n  # Print the current date\n  - trigger: ':date'\n    replace: '{{mydate}}'\n    vars:\n      - name: mydate\n    type: date\n    params:\n      format: '%m/%d/%Y'\n  # Print the output of a shell command\n  - trigger: ':shell'\n    replace: '{{output}}'\n    vars:\n      - name: output\n    type: shell\n    params:\n      cmd: 'echo ''Hello from your shell'''\n  # And much more! For more information, visit the docs: https://espanso.org/docs/\n  # misc\n  - trigger: ;&gt;&gt;\n    replace: ➡\n  - trigger: ;vv\n    replace: ⬇\n  - trigger: ;^^\n    replace: ⬆\n  - trigger: ;&lt;&lt;\n    replace: ⬅\n  # life\n  - trigger: ;mobi\n    replace: 我的手机号\n  - trigger: ;mail\n    replace: 我的邮箱\n  - trigger: ;addr\n    replace: 我的家庭住址\n  - trigger: ;officeAddr\n    replace: 公司地址\n  # faq\n  - trigger: chongt\n    replace: 冲突了，merge 下 master。\n  # code\n  - trigger: ;log\n    replace: console.log($|$)\n  - trigger: ;delay\n    replace: const delay = (ms) =&gt; new Promise((res) =&gt; setTimeout(res, ms));\n  # mac symbols\n  - trigger: ':cmd'\n    replace: ⌘\n  - trigger: ':shift'\n    replace: ⇧\n  - trigger: ':ctrl'\n    replace: ⌃\n  - trigger: ':alt'\n    replace: ⌥\n  - trigger: ':opt'\n    replace: ⌥\n  - trigger: ':left'\n    replace: ←\n  - trigger: ':right'\n    replace: →\n  - trigger: ':up'\n    replace: ↑\n  - trigger: ':down'\n    replace: ↓\n  - trigger: ':caps_lock'\n    replace: ⇪\n  - trigger: ':esc'\n    replace: ⎋\n  - trigger: ':eject'\n    replace: ⏏\n  - trigger: ':return'\n    replace: ↵\n  - trigger: ':enter'\n    replace: ⌅\n  - trigger: ':tab'\n    replace: ⇥\n  - trigger: ':backtab'\n    replace: ⇤\n  - trigger: ':pgup'\n    replace: ⇞\n  - trigger: ':pgdown'\n    replace: ⇟\n  - trigger: ':home'\n    replace: ↖\n  - trigger: ':end'\n    replace: ↘\n  - trigger: ':space'\n    replace: ␣\n  - trigger: ':del'\n    replace: ⌫\n  - trigger: ':fdel'\n    replace: ⌦\n</code></pre>\n<ol start=\"7\">\n<li>\n<p>VSCode<br>\n略</p>\n</li>\n<li>\n<p>Git</p>\n</li>\n</ol>\n<p>先配 name 和 email。</p>\n<pre><code>git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;you@your-domain.com&quot;\n</code></pre>\n<p>再执行这两条命令。</p>\n<pre><code>git config --global --add push.default currentgit config --global --add push.autoSetupRemote true\n</code></pre>\n<p>你会收获两个好处。1）不需要「git push origin xxx」，只要「git push」，2）再也不会遇到「no upstream branch」的报错，也不需要「git push --set-upstream origin test &amp;&amp; git push」。因为我们执行 git push 的大部分场景都是 push 到同名的 remote branch。来源是 Auto setup remote branch and never again see an error about the missing upstream | <a href=\"http://pawelgrzybek.com\">pawelgrzybek.com</a>。</p>\n<p>再修改 ~/.gitignore_global，加入和你 IDE 相关的 ignore 配置。我会把 .idea 加进去，这是和你相关的专有配置，如果给其他用 VSCode 的作者的项目提交时，都加上 .idea 的 .gitignore 配置，其实并不太礼貌。反之，VSCode 或其他编辑器工具的用户也要加上自己的。</p>\n<pre><code>*~.DS_Store.idea\n</code></pre>\n<ol start=\"9\">\n<li>NVM 和 Node</li>\n</ol>\n<pre><code>nvm install 18node -v\n</code></pre>\n<h2>系统设置</h2>\n<ol>\n<li>General。1）Default Web Browser 用「Google Chrome」</li>\n<li>Siri。直接禁掉。</li>\n<li>Keyboard。1）Keyboard 里把 Key Repeat 调到「Fast」，把 Delay Util Repeat 调到「Short」，需要一点时间适应，适应后会感受到光标快速移动带来的效率提升，2）Text 里 use <code>&quot;</code> for double quotes，use <code>'</code> for single quotes，然后把其他都禁掉，不需要系统帮忙改，基本都是帮倒忙的，3）Shortcuts 里，Mission Control 用「⌥A」,Application windows 用「⌥S」，Show Desktop 用「⌥D」</li>\n<li>Spotlight。只开 Applications、Bookmarks &amp; History、Documents、Folders、System Preferences。</li>\n<li>Mission Control。把 Hot Corners 里的全部关掉，不需要，因为有 Thor 了，可以更快切除应用。</li>\n<li>Notification。不必要的全关掉，我只开了 Calendar、Find By。</li>\n<li>执行 <code>defaults write -g NSWindowShouldDragOnGesture -bool true</code>，然后就可以按住「⌘+⌃」然后鼠标点击任意地方拖动窗口了。</li>\n</ol>\n",
            "url": "https://ajiu9.cn/posts/configure-my-Mac-from-0",
            "title": "从0开始配置我的Mac",
            "date_modified": "2024-01-04T00:00:00.000Z",
            "author": {
                "name": "Ajiu9",
                "url": "https://ajiu9.cn"
            }
        },
        {
            "content_html": "<table>\n<thead>\n<tr>\n<th>快捷键</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>⇧⌘P</td>\n<td>Show Command Palette （显示命令面板）</td>\n</tr>\n<tr>\n<td>⌘P</td>\n<td>Quick Open, Go to File… （快速打开文件）</td>\n</tr>\n<tr>\n<td>⌘W</td>\n<td>Close window/instance (关闭窗口/当前页)</td>\n</tr>\n<tr>\n<td>⌃P</td>\n<td>Select Previous in Quick Open (快速打开已选择过的文件)</td>\n</tr>\n<tr>\n<td>⌃Q</td>\n<td>Quick open navigate next in view picker (快速打开视图选择器导航)</td>\n</tr>\n<tr>\n<td>⇧⌘.</td>\n<td>Focus and select breadcrumbs, go to symbol inaccessible view (聚焦并选择面包屑，转到可访问视图中的符号)</td>\n</tr>\n<tr>\n<td>⌘F</td>\n<td>Find (搜索)</td>\n</tr>\n<tr>\n<td>⌥⌘F</td>\n<td>Replace (替换)</td>\n</tr>\n<tr>\n<td>⇧⌘F</td>\n<td>Show Search （-全局搜索）</td>\n</tr>\n<tr>\n<td>⇧⌥F</td>\n<td>Format document （格式化代码）</td>\n</tr>\n<tr>\n<td>⌘G</td>\n<td>Go to line (跳转行)</td>\n</tr>\n<tr>\n<td>⌘B</td>\n<td>Toggle sidebar visibility(切换侧边栏显示)</td>\n</tr>\n<tr>\n<td>⌃`</td>\n<td>Show integrated terminal (显示集成终端)</td>\n</tr>\n<tr>\n<td>⌃-</td>\n<td>Input back (光标返回)</td>\n</tr>\n<tr>\n<td>⇧⌘\\</td>\n<td>Jump to matching bracket (跳转到匹配的括号)</td>\n</tr>\n<tr>\n<td>⌘Enter/⇧⌘Enter</td>\n<td>Insert the line below/above</td>\n</tr>\n<tr>\n<td>⇧⌘B/⌘B</td>\n<td>View: Toggle Secondary Side Bar Visibility(切换侧边栏)</td>\n</tr>\n<tr>\n<td>⌥⌘⬅</td>\n<td>View: Open Previous Editor/Tab(打开上一个标签页)</td>\n</tr>\n<tr>\n<td>⌥⌘➡</td>\n<td>View: Open Next Editor/Tab(打开下一个标签页)</td>\n</tr>\n<tr>\n<td>⌃-</td>\n<td>Navigate Back (返回上一个导航)</td>\n</tr>\n<tr>\n<td>⇧⌃-</td>\n<td>Navigate Forward (打开后一个导航)</td>\n</tr>\n<tr>\n<td>⌘\\</td>\n<td>Split Right （右拆分）</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p><img src=\"https://static.ajiu9.cn/Notes/2023101020015616969393161696939316647dHJymT.png\" alt=\"hotkey\"></p>\n",
            "url": "https://ajiu9.cn/posts/common-shortcuts-for-vscode",
            "title": "vscode常用快捷键",
            "date_modified": "2023-10-25T00:00:00.000Z",
            "author": {
                "name": "Ajiu9",
                "url": "https://ajiu9.cn"
            }
        },
        {
            "content_html": "<p>这是一篇自我学习和思考的记录，同时参考自己的实际来实现自己应该怎么确定目标和完成计划。</p>\n<p>1、首先介绍<strong>4个我个人认同的理念</strong>，健康第一、选择难的、选择可以带来更多可能性的、选择有复利效应的。在做选择时多想想这些，可以更快并且做出更符合长期利益的选择。</p>\n<p>2、介绍一些方法论，包括定目标的WHEN、HOW、WHAT，以及基于LexFridman的方法改造的每日工作流。</p>\n<h3>理念</h3>\n<p>先说一些虚的理念，或者是指导性原则。<br>\n1、<strong>健康第一</strong>。自己的身体健康永远第一位，否则没法好好陪伴家人，也没法好好工作。跑步锻炼老是提起，又很快忘掉，没有坚持下去。现在计划每天拿出一个小时来锻炼身体。</p>\n<p>2、<strong>选择难的</strong>。左传中有一段话<em>取人之上，得其中也；取人之中，得其下也。</em> 如果你追求最高的标准，你可能会达到一种中等的状态；如果你只追求中等的标准，你可能会降至一个低等的状态。提醒我们要有高的目标和期望。应为实际结果往往要比期望的要低一些。</p>\n<p>3、<strong>选择可以带来更多可能性的</strong>。和上一条有些重合，选择难的通常可以带来更多可能性。比如科学上网、ChatGPT、Copilot、English、Google等，因为它们可以带来更多可能性。</p>\n<p>4、<strong>选择有复利效应的</strong>。有复利效应的事有写工具、写文档、学英语、写作、当然还有摇人【人多力量大】、懂取舍（知道不做什么）、解决痛点问题、多教多分享、多输入（只有输入足够多的知识才能做更好的决策）、本质解和现象解等。</p>\n<h3>方法</h3>\n<p>不管工作还是个人的，都是在走[定目标，拆目标，执行，完成🎉]这个循环，但是要确保目标很好地被完成，需要考虑什么时候定，怎么定，怎么执行。</p>\n<p><strong>什么时候定目标</strong> ？越早越好，我刚开始执行，所以就是现在，我的目标包括个人的和工作的，最近思考了下自己的未来，自己以后想做什么，爱好是什么，能做什么，然后开始定目标，立flag。</p>\n<p><strong>怎么定目标</strong>？我把自己想到的，眼前想做的，以后想做的，能做的，都写下来，然后问下家人的想法，然后作为今年的目标，今年只剩下一个季度了，哎，时间如流水，不舍昼夜。然后从中选出3-5个作为今年的最终目标。</p>\n<p><strong>怎么执行</strong>？先拆目标，到里程碑维度，每个里程碑包含时间、负责人和具体的大任务；负责人主要是我自己。然后通过月计划、周计划、日计划进一步拆分；月计划和周计划拆分到以h为单位，日计划拆分到最多1h能完成的程度。我现在只做周计划和日计划，还没有月计划。每周日确定下周的日计划，每天前一天确定后一天的日计划。月末我会做定期回顾和整理，先这样执行，视情况调整。</p>\n<p><strong>每天怎么安排</strong>？我参考的是Lex Fridman的每日工作流。他的日常是这样的：</p>\n<ul>\n<li>deep work 4h</li>\n<li>社交媒体和音乐 30m</li>\n<li>运动 2h</li>\n<li>deep work 4h</li>\n<li>晚餐</li>\n<li>shallow work 4h</li>\n<li>晚间阅读 2h</li>\n</ul>\n<p>我的时间安排：</p>\n<ul>\n<li>6:30 - 7:30 英语</li>\n<li>7:30 - 8:50 上班</li>\n<li>9:00 - 11: 15 Deep Work</li>\n<li>11:15 - 11: 40 午饭</li>\n<li>11：40 - 12:10 资讯</li>\n<li>12:10 - 13:10 读书</li>\n<li>13:10 - 13:30 午休</li>\n<li>13:30 - 17:30 Deep Work</li>\n<li>17:30 - 16:20 社交媒体</li>\n<li>18:20 - 19:00 回家</li>\n<li>19:00 - 20:00 锻炼</li>\n<li>20:00 - 21:00 亲子时间</li>\n<li>21:00 - 23:00 Shallow Work</li>\n</ul>\n<p>工作时间不回复不重要的消息，早上优先做昨天设定的3Frog任务，周日周末时间表不同，我可能在家带娃，或者户外活动。同时保证4小时的长文阅读，4小时的Deep Work。</p>\n<p><img src=\"https://static.ajiu9.cn/Notes/2023101520370316973734231697373423408sJebk1.png\" alt=\"daily plan\"></p>\n",
            "url": "https://ajiu9.cn/posts/how-to-determine-the-plan",
            "title": "怎么确定年目标，周计划，日计划",
            "date_modified": "2023-09-17T00:00:00.000Z",
            "author": {
                "name": "Ajiu9",
                "url": "https://ajiu9.cn"
            }
        },
        {
            "content_html": "<blockquote>\n<p>对于经常写笔记的人来说，图片是必然不可少的。为了更好地管理和展示图片，可以搭建自己的图床。这是一篇总结如何使用uPic和阿里OSS来搭建和使用个人图床，轻松使用图片</p>\n</blockquote>\n<h3>图床使用uPic</h3>\n<pre><code class=\"language-cmd\">brew install bigwig-club/brew/upic --cask\n</code></pre>\n<h3>阿里OSS申请购买</h3>\n<blockquote>\n<p>OSS使阿里云的对象存储服务，需要付费使用，但是对于平常的博客文章而言，很便宜，我现在是申请的3个月免费使用，实际付费也不贵，一个月就2.16元，（资源包关联的按量付费实例不停机，按使用量收费），就平常的访问量而言，估计是很难超过使用量的。</p>\n</blockquote>\n<p><img src=\"https://static.ajiu9.cn/Notes/IITkfA.png\" alt=\"每月价格\"></p>\n<h3>配置OSS</h3>\n<p>有了OSS后，需要简单配置下，阿里云有官方教程，一步一步几分钟搞定。</p>\n<ul>\n<li>\n<ol>\n<li>创建bucket <img src=\"https://static.ajiu9.cn/Notes/5eGHP4.png\" alt=\"bucket\"></li>\n</ol>\n</li>\n<li>\n<ol start=\"2\">\n<li>击立即创建，勾选配置<img src=\"https://static.ajiu9.cn/Notes/nKvi0c.png\" alt=\"配置\"></li>\n</ol>\n</li>\n<li>\n<ol start=\"3\">\n<li>配置完成，如果有自己的域名的话可以配置好自己的域名，<s>我现在用的是阿里云的默认域名，还没买，下次再申请</s></li>\n</ol>\n</li>\n</ul>\n<ol>\n<li>在 AccessKey管理中找到对应的key填写到uPic中<img src=\"https://static.ajiu9.cn/Notes/20230917112327.png\" alt=\"AccessKey\"></li>\n</ol>\n<h3>uPic图床配置</h3>\n<p>在uPic偏好设置中，设置好图床！<br>\n<img src=\"https://static.ajiu9.cn/Notes/20230917162239169493895916949389595970bFTu6.png\" alt=\"图床配置\"></p>\n<h3>完成</h3>\n<p>配置完成后就可以愉快的引用图片到文章中了，最后可以设置下图床的快捷键<img src=\"https://static.ajiu9.cn/Notes/2023091716261416949391741694939174953lwT8Qv.png\" alt=\"快捷键\"></p>\n",
            "url": "https://ajiu9.cn/posts/construction-and-use-of-picture-bed",
            "title": "图床，uPic和阿里oss搭建和使用",
            "date_modified": "2023-09-16T00:00:00.000Z",
            "author": {
                "name": "Ajiu9",
                "url": "https://ajiu9.cn"
            }
        },
        {
            "content_html": "<p>1.使用speed-measure-webpack-plugin进行速度分析</p>\n<pre><code class=\"language-javascript\">// 安装\nnpm install --save-dev speed-measure-webpack-plugin\n// 使用方式\nconst SpeedMeasurePlugin = require(&quot;speed-measure-webpack-plugin&quot;);\nconst smp = new SpeedMeasurePlugin();\nconst webpackConfig = smp.wrap({\n  plugins: [\n    new MyPlugin(),\n    new MyOtherPlugin()\n  ]\n});\n</code></pre>\n<ol start=\"2\">\n<li>使用webpack-bundle-analyzer进行体积分析</li>\n</ol>\n<pre><code class=\"language-javascript\">// 安装\nnpm install --save-dev webpack-bundle-analyzer\n// 使用\nconst BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;\nmodule.exports = {\n plugins: [\n   new BundleAnalyzerPlugin()\n ]\n}\n</code></pre>\n<ol start=\"3\">\n<li>使用多进程、多实例构建\n<blockquote>\n<p>使用<a href=\"https://webpack.js.org/loaders/thread-loader/\">thread-loader</a>: 每次 webpack 解析一个模块，thread-loader 会将它及它的依赖分配给 worker 线程中</p>\n</blockquote>\n</li>\n</ol>\n<pre><code class=\"language-javascript\">// webpack.config.js\nconst os = require('os')\nconst threads = os.cpus().length\nconsole.info('编译线程数 =&gt; ', threads)\nmodule.exports = {\n  config.module\n    .rule('vue')\n    .use('thread-loader')\n    .loader('thread-loader')\n    .options({\n      workers: threads\n    })\n    .end()\n  config.module\n    .rule('js')\n    .use('thread-loader')\n    .loader('thread-loader')\n    .options({\n      workers: threads\n    })\n    .end()\n};\n</code></pre>\n<ol start=\"4\">\n<li>利用缓存提升二次构建速度\n<blockquote>\n<p><a href=\"https://webpack.js.org/configuration/cache/#cachetype\">bable-loader</a>提供了一个参数来使用缓存, 有false,memory, filesystem等配置</p>\n</blockquote>\n</li>\n</ol>\n<pre><code class=\"language-javascript\">module.exports = {\n  //...\n  cache: {\n    type: 'filesystem',\n  },\n};\n</code></pre>\n<ol start=\"5\">\n<li>在webpack构建过程中移除无用的css代码方式\n<blockquote>\n<p><a href=\"https://www.npmjs.com/package/mini-css-extract-plugin\">mini-css-extract-plugin</a>此插件将CSS提取到单独的文件中。它为每个包含CSS的JS文件创建一个CSS文件。它支持CSS和SourceMaps的按需加载。<br>\n它建立在新的webpack v5功能之上，需要webpack 5才能工作。</p>\n</blockquote>\n</li>\n</ol>\n<pre><code class=\"language-javascript\">const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);\n\nmodule.exports = {\n  plugins: [new MiniCssExtractPlugin()],\n  module: {\n    rules: [\n      {\n        test: /\\.css$/i,\n        use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;],\n      },\n    ],\n  },\n};\n</code></pre>\n<p>6.对图片进行优化</p>\n<blockquote>\n<p>使用<a href=\"https://webpack.js.org/configuration/module/#ruleparserdataurlcondition\">ruleparserdataurlcondition</a>减少http请求</p>\n</blockquote>\n<pre><code class=\"language-javascript\">module.exports = {\n  //...\n  module: {\n    rules: [\n      {\n        //...\n        parser: {\n          dataUrlCondition: {\n            maxSize: 4 * 1024,\n          },\n        },\n      },\n    ],\n  },\n};\n</code></pre>\n<p>7.在生产构建时，使用代码拆分、splitChunks优化</p>\n<blockquote>\n<p><a href=\"https://webpack.js.org/configuration/optimization/\">optimization</a>开启minimize： true, 配置<a href=\"https://webpack.js.org/configuration/optimization/#optimizationsplitchunks\">splitChunks</a>来拆分合并代码，优化生产环境的代码，对常用的公用代码使用CDN<br>\n<a href=\"https://medium.com/webpack/webpack-4-code-splitting-chunk-graph-and-the-splitchunks-optimization-be739a861366\">webpack-4-code-splitting-chunk-graph-and-the-splitchunks-optimization</a><br>\n比如对第二步中使用webpack-bundle-analyzer进行体积分析后得到的优化建议，可以配置一下代码来进行优化</p>\n</blockquote>\n<pre><code class=\"language-javascript\">module.exports = {\nsplitChunks: {\n      chunks: 'async',\n      minChunks: 1,\n      maxInitialRequests: 30,\n      minSize: 0,\n      cacheGroups: {\n        default: {\n          minChunks: 1,\n          priority: -20,\n          reuseExistingChunk: true\n        },\n        coreJs: {\n          chunks: 'all',\n          name: 'lib.core-js',\n          test: /[\\\\/]node_modules[\\\\/]core-js[\\\\/]/\n        },\n        axios: {\n          chunks: 'all',\n          name: 'lib.axios',\n          test: /[\\\\/]node_modules[\\\\/](axios|axios-ex)[\\\\/]/\n        },\n        handsontable: {\n          chunks: 'all',\n          name: 'lib.handsontable',\n          test: /[\\\\/]node_modules[\\\\/](handsontable|@handsontable)[\\\\/]/\n        },\n        lodash: {\n          chunks: 'all',\n          name: 'lib.lodash',\n          test: /[\\\\/]node_modules[\\\\/]lodash[\\\\/]/\n        },\n        moment: {\n          chunks: 'all',\n          name: 'lib.moment',\n          test: /[\\\\/]node_modules[\\\\/]moment[\\\\/]/\n        },\n        i18n: {\n          chunks: 'all',\n          name: 'lib.i18n',\n          test: /[\\\\/]node_modules[\\\\/]vue-i18n[\\\\/]/\n        },\n        common: {\n          chunks: 'all',\n          name: 'lib.common',\n          priority: 0,\n          test(module) {\n            const includes = [\n              'intro.js',\n              'countup.js',\n              'qs',\n              'node-rsa',\n              'vue-grid-layout'\n            ]\n            return (\n              module.resource &amp;&amp;\n              includes.some(pkg =&gt;\n                module.resource.includes(\n                  `${sep}node_modules${sep}${pkg}${sep}`\n                )\n              )\n            )\n          }\n        }\n      }\n    }\n}\n</code></pre>\n",
            "url": "https://ajiu9.cn/posts/webpack-building-speed-up",
            "title": "前端webpack构建提速",
            "date_modified": "2023-01-04T00:00:00.000Z",
            "author": {
                "name": "Ajiu9",
                "url": "https://ajiu9.cn"
            }
        },
        {
            "content_html": "<h4>创建对象的几种方法</h4>\n<pre><code class=\"language-js\">// 1.使用new Object()\nvar o1 = new Object({name: 'o1'});\n// 2.对象字面量 (这种方法其实就是第一种的简写)\nvar o2 = {name: 'o2'};\n// 3.构造函数\nvar A = function(name) {\nthis.name = name;\n}\nvar o3 = new A('o3');\n// 4.Object.create()\nvar B = {name: 'o4'};\nvar o4 = Object.create(B);\n</code></pre>\n<h4>构造函数、原型、实例、原型链</h4>\n<p>JavaScript是一门面向对象基于原型继承的语言,那么原型到底是怎么实现继承的？</p>\n<p><img src=\"https://static.ajiu9.cn/images/20240311231356CGtgQw.png\" alt=\"图片\"></p>\n<p>prototype原型是一个对象，只有函数才有的属性，这是在创建函数是js引擎自动添加的属性，其他对象可以通过它实现属性继承。<br>\n<code>__proto__</code>是每个对象都有的属性，但不是一个规范属性，它指向的是构造函数的原型对象。(<code>__proto__</code>通过上面第四种方式<code>Object.create(O))</code>指向的是对象O)</p>\n<pre><code class=\"language-js\">// 1.创建构造函数Animal\nvar Animal = function(name) {    \n  this.name = name\n}\n// 2.实例化一个对象dog\nvar dog = new Animal('dog');\n// Animal 构造函数的原型的constructor属性指向构造函数本身\nAnimal.prototype.constructor === Animal // true\n// dog实例的__proto__指向构造函数的原型\ndog.__proto__ === Animal.prototype // true\n</code></pre>\n<p>原型链指由于<code>__proto__</code>是对象都有的属性，所以会形成一条由<code>__proto__</code>连起来的链条，递归访问<code>__proto__</code>最终到终点，最后指向<code>null</code>.<br>\n当js查找对象的属性时，先查找对象本身有没有这个属性，如果不存在，就会在原型链上查找，直到找到或者到达终点的<code>null</code>。</p>\n<h4>instanceof运算符</h4>\n<p><code>instanceof</code>运算符用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置</p>\n<p><img src=\"https://static.ajiu9.cn/images/20240311231424c991rT.png\" alt=\"图片\"></p>\n<p>用<code>instanceof</code>来判断实例对象是否为构造函数直接生成的对象并不严格，因为出现在对象原型链中任何位置都会返回true，这时可以使用对象的<code>__proto__.constructor</code>是否严格等于构造函数来判断。</p>\n<pre><code class=\"language-js\">// 测试构造函数的prototype属性是否出现在对象的原型链中\ndog instanceof Animal; // true\ndog instanceof Object; // true\n// 判断实例对象是否为构造函数直接生成\ndog.__proto__.constructor === Animal; // true\n</code></pre>\n<h4>new 运算符</h4>\n<p>执行new后</p>\n<ul>\n<li>一个新对象被创建，它继承自构造函数foo.prototype</li>\n<li>构造函数foo被执行。执行的时候，相应的参数被传入，同时上下文<code>this</code>会被指定为这个新实例。 <code>new foo</code> 等于 <code>new foo()</code>,只能用在不传递任何参数的情况下。</li>\n<li>如果构造函数返回了一个对象，那么这个对象会整个取代new出来的结果。如果构造函数没有返回对象，那么new出来的结果为第一步创建的对象。</li>\n</ul>\n<pre><code class=\"language-js\">// new 的执行如下\nvar new1 = function(func) {    \n// 第一步:一个新对象被创建，它继承自构造函数func.prototype  \n  var o = Object.create(func.prototype);    \n // 第二步：构造函数func被执行。执行的时候，相应的参数被传入，同时上下文`this`会被指定为这个新实例。    \n var k = func.call(o);    \n // 第三步   \n  if (typeof k === 'object') {\n     return k\n   } else {\n     return o\n   }\n}\n// 验证new内部原理是否和new1函数的执行过程一样\n//构造函数\nvar A = function(name) {   \n   this.name = name;\n}\n// new运算符\nvar o3 = new A('o3');\n// new1()\nvar o6 = new1(A);\n// 接下来验证通过new1生成的o6对象是否和new生成的o3一样\no6 instanceof A; // true\no6 instanceof Object; // true\no6.__proto__.constructor === A; // true\nA.prototype.walk= function(){\n  console.log('walk')\n}\no6.walk() // walk\no3.walk() // walk\n</code></pre>\n<p>通过上面的代码可以看出，new的执行原理了吧。</p>\n",
            "url": "https://ajiu9.cn/posts/constructor-instance-prototype-chain",
            "title": "构造函数、原型、实例、原型链的关系",
            "date_modified": "2018-09-28T00:00:00.000Z",
            "author": {
                "name": "Ajiu9",
                "url": "https://ajiu9.cn"
            }
        },
        {
            "content_html": "<h4>什么是同源策略及限制</h4>\n<p>同源策略，它是由Netscape提出的一个著名的安全策略，现在所有支持JavaScript 的浏览器都会使用这个策略。限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。<br>\n所谓同源是指，域名，协议，端口（http协议的默认端口是80）相同。<br>\n例如一个浏览器的两个tab页中分别打开来百度和谷歌的页面，当浏览器的百度tab页执行一个脚本的时候会检查这个脚本是属于哪个页面的，即检查是否同源，只有和百度同源的脚本才会被执行。如果非同源，那么在请求数据时，浏览器会在控制台中报一个异常，提示拒绝访问。</p>\n<p>限制：</p>\n<ul>\n<li>\n<p>Cookie、LocalStorage和IndexDB无法获取。</p>\n</li>\n<li>\n<p>无法获取和操作DOM。</p>\n</li>\n<li>\n<p>不能发送Ajax请求。</p>\n</li>\n</ul>\n<h4>前后端如何通信</h4>\n<ul>\n<li>\n<p>Ajax：同源下的通信方式。</p>\n</li>\n<li>\n<p>WebSocket：不受同源策略的限制，支持跨域。</p>\n</li>\n<li>\n<p>CORS： CORS是跨源资源分享（Cross-Origin Resource Sharing）的缩写。它是W3C标准，是跨源AJAX请求的根本解决方法。相比JSONP只能发GET请求，CORS允许任何类型的请求。</p>\n</li>\n</ul>\n<h4>如何创建Ajax</h4>\n<p>需要知道以下几点：</p>\n<ul>\n<li>\n<p>XMLHttpRequest的工作原理</p>\n</li>\n<li>\n<p>兼容性处理（XMLHttpRequest只在高版本的浏览器支持）</p>\n</li>\n<li>\n<p>事件的触发条件</p>\n</li>\n<li>\n<p>事件的触发顺序</p>\n</li>\n</ul>\n<pre><code class=\"language-js\">util.ajax = function (options) {\n  const opt = Object.assin({\n    url: '',\n    ype: 'get',\n    data: {},\n    success() {},\n    error() {},\n  }, options)\n\n  if (opt.url) {\n    // 兼容性处理\n    const xhr = XMLHttpRequest\n      ? new XMLHttpRequest()\n      : new ActiveXObject('Microsoft.XMLHTTP')\n    const data = opt.data\n    let url = opt.url\n    const type = opt.type.toUpperCase()\n    const dataArr = []\n    for (const k in data)\n      dataArr.push(`${k}=${data[k]}`)\n\n    if (type === 'GET') {\n      url = `${url}?${dataArr.join('&amp;')}`\n      xhr.open(type, url.replace(/\\?$/g, ''), true)\n      xhr.send()\n    }\n    if (type === 'POST') {\n      xhr.open(type, url, true)\n      xmlhttp.setRequestHeader('Content-type', 'application/x-www-form-urlencoded')\n      xhr.send(dataArr.join('&amp;'))\n    }\n    xhr.onload = function () {\n      if (xhr.status === 200 || xhr === 304) {\n        var res\n        if (opt.success &amp;&amp; opt.success instanceof Function) {\n          res = xhr.responseText\n          if (typeof res === 'string') {\n            res = JSON.parse(res)\n            opt.success.call(xhr, res)\n          }\n        }\n      }\n      else {\n        if (opt.error &amp;&amp; opt.error instanceof Function)\n          opt.error.call(xhr, res)\n      }\n    }\n  }\n}\n</code></pre>\n<h4>跨域通信的几种方式</h4>\n<ul>\n<li>jsonp</li>\n<li>Hash</li>\n<li>webSocket</li>\n<li>postMessage</li>\n<li>CORS</li>\n</ul>\n<p><strong>1.jsonp</strong><br>\njsonp原理： 通过<code>&lt;script&gt;</code>标签的异步加载来实现。例如在<code>&lt;head&gt;</code>标签中通过<code>&lt;script&gt;</code>中的url加载的js。</p>\n<pre><code class=\"language-js\">/**\n* [function 拼接url]\n* @param  {[Object]]} data [description]\n* @return {[value=key&amp;value1=key1]} [description]\n*/var util = {}\nutil.param = function (data) {\n  var url = ''\n  for (var k in data) {\n    let value = data[k] !== undefined ? data[k] : ''\n    url += `&amp;${k}=${encodeURIComponent(value)}`\n  }\n  return url ? url.substring(1) : ''\n}\n/**\n  * [function 判断是否为函数]\n  * @param  {[type]} source [description]\n  * @return {[type]}        [description]\n  */\nutil.isFunction = function (source) {\n  return '[object Function]' === Object.prototype.toString.call(source);\n};\n/**\n  * [function 获取一个随机的5位字符串]\n  * @param  {[type]} prefix [description]\n  * @return {[type]}        [description]\n  */\n util.getName = function (prefix) {\n    return prefix + Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 5);\n  };\n/**\n  * [function 在页面中注入js脚本]\n  * @param  {[type]} url     [description]\n  * @param  {[type]} charset [description]\n  * @return {[type]}         [description]\n  */\n util.createScript = function (url, charset) {\n  var script = document.createElement('script');\n  script.setAttribute('type', 'text/javascript');\n  charset &amp;&amp; script.setAttribute('charset', charset);\n  script.setAttribute('src', url);\n  script.async = true;\n  return script;\n};\n// jsop实现\nutil.jsonp = function(url, data, onsuccess, onerror, charset) {\n  // 第一步，全局注册一个callback回调函数\n  var callbackName = util.getName(_callback);\n  window[callbackName] = function() {\n    if (onsuccess &amp;&amp; onsuccess.util.isFunction) {\n       onsuccess(arguments[0]);\n    }\n  }\n  // 第二步 动态创建Script标签\n  url += (url.indexOf('?') &lt; 0 ? '?' : '&amp;') + util.param(data);\n  var script = util.createScript(url + '&amp;callback=' + callbackName, charset);\n  // 第三步 发送script请求\n  document.getElementsByTagName('head')[0].appendChild(script);\n  // 第四步 监听函数\n  script.onload = script.onreadystatechange = function () {\n    if (!script.readyState || /loaded|complete/.test(script.readyState)) {\n      script.onload = script.onreadystatechange = null;// 移除该script的 DOM 对象\n      if (script.parentNode) {\n        script.parentNode.removeChild(script);\n      }\n    // 删除函数或变量\n    window[callbackName] = null;\n  }\n};\nscript.onerror = function () {\n  if (onerror &amp;&amp; util.isFunction(onerror)) {\n    onerror();\n  }\n};\n}\n</code></pre>\n<p>实例：</p>\n<pre><code class=\"language-js\">util.jsonp('https://c.y.qq.com/musichall/fcgi-bin/fcg_yqqhomepagerecommend.fcg', {\n  g_tk: 5381,\n  inCharset: 'utf-8',\n  outCharset: 'utf-8',\n  notice: 0,\n  format: 'jsonp',\n  platform: ' h5',\n  uin: 0,\n  needNewCode: 1\n}, function () {\n  console.log(arguments)\n})\n</code></pre>\n<p><strong>2.Hash（片段识别符）</strong><br>\nurl的<code>#</code>后面的内容就叫Hash。Hash的改变，页面不会刷新。这就是用 Hash 做跨域通信的基本原理(url的?后面的内容叫Search。Search的改变，会导致页面刷新)。<br>\n实例：<br>\n页面A通过iframe或frame嵌入了跨域页面B。<br>\n窗口可以把信息，写入子窗口的片段标识符。</p>\n<pre><code class=\"language-js\">var src = originURL + '#' + data;\ndocument.getElementById('myIFrame').src = src;\n</code></pre>\n<p>子窗口通过监听hashchange事件得到通知。</p>\n<pre><code class=\"language-js\">window.onhashchange = checkMessage;\nfunction checkMessage() {var message = window.location.hash;\n// ...\n}\n</code></pre>\n<p>同样的，子窗口也可以改变父窗口的片段标识符。</p>\n<pre><code class=\"language-js\">parent.location.href= target + &quot;#&quot; + hash;\n</code></pre>\n<p><strong>3.postMessage</strong><br>\nHTML5引入了一个全新的API：跨文档通信 API（Cross-document messaging）。这个API为window对象新增了一个window.postMessage方法，允许跨窗口通信，不论这两个窗口是否同源。</p>\n<pre><code class=\"language-js\">// postMessage\n// 窗口A(http:A.com)向跨域的窗口B(http:B.com)发送信息B\nwindow.postMessage('data', 'http://B.com');\n// 在窗口B中监听A\nwindow.addEventListener('message', function (event) {console.log(event.origin)});\n// 发送消息的窗口console.log(event.source); \n// 消息发向的网址console.log(event.data); \n// 消息内容}, false);\n</code></pre>\n<p><strong>4.webSocket</strong><br>\nWebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。</p>\n<pre><code class=\"language-js\">var ws = new webSocket(&quot;wss://echo.websocket.org&quot;);\nws.onopen = function(evt) {console.log(&quot;Connection open ...&quot;);\nws.send(&quot;Hello WebSockets!&quot;);\n};\n\nws.onmessage = function(evt) {console.log( &quot;Received Message: &quot; + evt.data);\nws.close();\n};\n\nws.onclose = function(evt) {console.log(&quot;Connection closed.&quot;);\n};\n</code></pre>\n<blockquote>\n<p>Websocket【参考资料】<a href=\"http://www.ruanyifeng.com/blog/2017/05/websocket.html\">http://www.ruanyifeng.com/blog/2017/05/websocket.html</a></p>\n</blockquote>\n<p><strong>4.CORS</strong><br>\nCORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。<br>\n跨域时，浏览器会拦截Ajax请求，并在http头中加Origin。</p>\n<pre><code class=\"language-js\">fetch('/some/url/', {\n  method: 'get',\n}).then(function (response) {\n  // 请求成功后执行操作\n}).catch(function (err) {\n  // 请求失败后执行操作\n});\n</code></pre>\n<p><a href=\"http://www.ruanyifeng.com/blog/2016/04/cors.html\">CORS【参考资料】</a></p>\n",
            "url": "https://ajiu9.cn/posts/cross-domain-methods",
            "title": "前端通信类以及跨域的几种方法",
            "date_modified": "2018-09-27T00:00:00.000Z",
            "author": {
                "name": "Ajiu9",
                "url": "https://ajiu9.cn"
            }
        },
        {
            "content_html": "<h4>事件级别</h4>\n<ul>\n<li>DOM0<br>\n<code>element.onclick = function(){}</code></li>\n<li>DOM2<br>\n<code>element.addEventListener('click', function(){}, false)</code></li>\n<li>DOM3<br>\n<code>element.addEventListener('keyup', function(){}, false</code><br>\n在DOM2事件后新增了UI事件、鼠标事件、键盘事件等事件类型</li>\n</ul>\n<h4>事件模型</h4>\n<ul>\n<li>事件捕获</li>\n<li>事件冒泡</li>\n</ul>\n<h4>DOM事件流</h4>\n<p>DOM(文档对象模型)结构是一个树型结构，当一个HTML元素产生一个事件时，该事件会在元素节点与根结点之间的路径传播，路径所经过的结点都会收到该事件，这个传播过程可称为DOM事件流。</p>\n<h4>DOM事件流的具体流程</h4>\n<p>在DOM兼容浏览器中，事件流中分三个级段：</p>\n<ul>\n<li>捕获阶段（Capture Phase）：事件从window自上而下向目标节点传播的阶段；</li>\n<li>目标阶段（Target Phase）：正的目标节点正在处理事件的阶段；</li>\n<li>冒泡阶段（Bubbling Phase）：事件从目标节点自上而下向window传播的阶段。<br>\n<img src=\"https://static.ajiu9.cn/images/20240310220404oy7dPw.png\" alt=\"图片\"></li>\n</ul>\n<h4>Event对象的常见应用</h4>\n<ul>\n<li>event.preventDefault() 阻止默认事件</li>\n<li>event.stopPropagation() 阻止捕获和冒泡阶段中当前事件的进一步传播</li>\n<li>event.stopImmediatePropagation() 阻止事件冒泡并且阻止相同事件的其他侦听器被调用</li>\n<li>event.currentTarget 当事件遍历DOM时，标识事件的当前目标。它总是引用事件处理程序附加到的元素(当前绑定的事件元素)</li>\n<li>event.target 标识事件发生的元素（当前被点击的元素）</li>\n</ul>\n<h4>自定义事件</h4>\n<blockquote>\n<p>语法<code>event = new Event(typeArg, eventInit);</code><br>\ntypeArg 是DOMString 类型，表示所创建事件的名称。<br>\neventInit可选,是 EventInit 类型的字典，接受以下字段:</p>\n<ul>\n<li>“bubbles”，可选，Boolean类型，默认值为 false，表示该事件是否冒泡。</li>\n<li>“cancelable”，可选，Boolean类型，默认值为 false， 表示该事件能否被取消。</li>\n<li>“composed”，可选，Boolean类型，默认值为 false，指示事件是否会在影子DOM根节点之外触发侦听器。</li>\n</ul>\n</blockquote>\n<pre><code>// 创建一个支持冒泡且不能被取消的attach事件var ev = new Event(&quot;attach&quot;, {&quot;bubbles&quot;:true, &quot;cancelable&quot;:false});document.dispatchEvent(ev);// 事件可以在任何元素触发，不仅仅是documentmyDiv.dispatchEvent(ev);\n</code></pre>\n<p><code>customEvent</code>事件是由程序创建的，可以有任意自定义功能的事件。</p>\n<pre><code>// 添加一个适当的事件监听器obj.addEventListener(&quot;cat&quot;, function(e) { process(e.detail) })// 创建并分发事件var event = new CustomEvent(&quot;cat&quot;, {&quot;bubbles&quot;: true, &quot;cancelable&quot;: false, &quot;detail&quot;:{&quot;hazcheeseburger&quot;:true}})\nobj.dispatchEvent(event)\n</code></pre>\n",
            "url": "https://ajiu9.cn/posts/dom-event",
            "title": "DOM事件",
            "date_modified": "2018-09-26T00:00:00.000Z",
            "author": {
                "name": "Ajiu9",
                "url": "https://ajiu9.cn"
            }
        },
        {
            "content_html": "<h3>CSS盒模型的基本概念</h3>\n<p>盒模型由内向外由content,padding, border, margin组成。<br>\n盒模型有两种：标准模型，IE模型。</p>\n<h3>标准模型和IE模型的区别</h3>\n<p>这俩种盒模型的区别是计算宽度和高度的不同。<br>\n标准模型的宽高只计算内容（content）,IE模型宽高计算为内容（content）+填充（padding）+边框（border）的总宽高。</p>\n<p><img src=\"https://static.ajiu9.cn/images/20240310214341Gxd31S.png\" alt=\"图片\"></p>\n<p><img src=\"https://static.ajiu9.cn/images/20240310214237UjGOJB.png\" alt=\"图片\"></p>\n<h3>如何设置这俩种盒模型</h3>\n<pre><code>/*标准模型*/\nbox-sizing: content-box;\n/*IE模型*/\nbox-sizing: border-box;\n</code></pre>\n<h3>JS如何获取盒模型的宽和高</h3>\n<pre><code>var node = document.getElementById('node')\n</code></pre>\n<ul>\n<li>\n<p>node.style.width/height<br>\n这种方式只能取到dom元素内联样式的宽和高，通过外联样式link引入和在style标签中设置的样式这两者都是获取不到node的宽和高的</p>\n</li>\n<li>\n<p>node.currentStyle.width/height<br>\n这种方式是获取渲染后的结果，但只在旧版本的IE浏览器中支持，该特性是非标准的，尽量不要在生产环境中使用它。</p>\n</li>\n<li>\n<p>window.getComputerStyle(node).width/height<br>\nWindow.getComputedStyle()方法返回一个对象，该对象在应用活动样式表并解析这些值可能包含的任何基本计算后报告元素的所有CSS属性的值。和上一种方式是相似的，但通用性更好。</p>\n</li>\n<li>\n<p>node.getBoundingClientRect().width/height<br>\nElement.getBoundingClientRect()方法返回元素的大小及其相对于视口的位置。包含边框(border)、内边距(padding)以及CSS设置的宽度(width)值</p>\n</li>\n<li>\n<p>node.offsetWidth/offsetHeight<br>\n这种方式是测量包含元素的边框(border)、内边距(padding)、滚动条(scrollbar)（如果存在的话）、以及CSS设置的宽度(width)和高度（height）的值。</p>\n</li>\n</ul>\n<h3>边距重叠</h3>\n<ul>\n<li>\n<p>父子元素边距重叠（子元素设置margin-top:20px; 父元素也一起有了上边距）</p>\n</li>\n<li>\n<p>兄弟元素边距重叠（兄弟元素的下边距margin-bottom和他兄弟元素上边margin-top距重叠，重叠规则是取它们之间最大值）</p>\n</li>\n<li>\n<p>空元素的边距重叠（空元素的上边距margin-top和下边距margin-bottom重叠，重叠规则是取它们之间最大值）</p>\n</li>\n</ul>\n<h3>边距重叠解决方案（BFC）</h3>\n<p>BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。</p>\n<h4>W3C对BFC的定义如下：</h4>\n<p>浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的BFC（块级格式上下文）。</p>\n<h4>BFC布局规则：</h4>\n<ul>\n<li>\n<p>内部的Box会在垂直方向属于同一个BFC的两个相邻Box的margin会发生重叠。</p>\n</li>\n<li>\n<p>BFC的区域不会与float box重叠。</p>\n</li>\n<li>\n<p>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之也如此。</p>\n</li>\n<li>\n<p>计算BFC的高度时，浮动元素也参与计算。</p>\n</li>\n</ul>\n<h3>如何创建BFC</h3>\n<p>根据BFC的定义，创建方式有几种</p>\n<ul>\n<li>\n<p>float属性不为none</p>\n</li>\n<li>\n<p>position为absolute或fixed</p>\n</li>\n<li>\n<p>display为inline-block, table-cell, table-caption, flex, inline-flex</p>\n</li>\n<li>\n<p>overflow不为visible</p>\n</li>\n</ul>\n<h3>应用场景</h3>\n<ul>\n<li>\n<p>自适应浮动布局中浮动重叠（给该自适应元素创建BFC）</p>\n</li>\n<li>\n<p>解决父子元素边距重叠（给父元素创建BFC）</p>\n</li>\n<li>\n<p>清楚浮动（给浮动元素的父元素创建BFC）</p>\n</li>\n</ul>\n",
            "url": "https://ajiu9.cn/posts/css-box-model-and-margin-overlap-solution",
            "title": "CSS盒模型和边距重叠解决方案（BFC）",
            "date_modified": "2018-09-25T00:00:00.000Z",
            "author": {
                "name": "Ajiu9",
                "url": "https://ajiu9.cn"
            }
        },
        {
            "content_html": "<h4>http简介</h4>\n<p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP）。<br>\n通常，由HTTP客户端发起一个请求，建立一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端发送过来的请求。一旦收到请求，服务器（向客户端）发回一个状态行，比如”HTTP/1.1 200 OK”，和（响应的）消息，消息的消息体可能是请求的文件、错误消息、或者其它一些信息。</p>\n<h4>http协议的主要特点</h4>\n<ul>\n<li>\n<p>简单快速 ：HTTP使用统一资源标识符（Uniform Resource Identifiers, URI）来传输数据和建立连接，URL是一种特殊类型的URI。访问某个资源只要输入URI即可。</p>\n</li>\n<li>\n<p>灵活：每个http协议中。有一个头部分，有个数据类型，通过一个http协议的就可以完成不同数据类型的传输。</p>\n</li>\n<li>\n<p>无连接：连接一次就会断开，不会保持连接。</p>\n</li>\n<li>\n<p>无状态：客户端和服务端通信，客户端向服务端发送请求，http建立连接、传输结束后，连接断开，下次客户端再请求数据，服务端是无法区分上次连接和这次连接是否是同一身份，因为服务端没有记住你的状态，从http协议上是无法区分两次连接者的身份。</p>\n</li>\n</ul>\n<h4>http报文的组成部分</h4>\n<ul>\n<li>请求报文：请求行、请求头、空行、请求体</li>\n<li>响应报文：状态行、响应头、空行、响应体</li>\n</ul>\n<p><img src=\"https://static.ajiu9.cn/images/20240310214516948RBW.png\" alt=\"图片\"></p>\n<p>请求报文格式</p>\n<p><img src=\"https://static.ajiu9.cn/images/20240310214534AyGWUp.png\" alt=\"图片\"></p>\n<h5>请求报文示例</h5>\n<pre><code>GET /build/music/ HTTP/1.1\nHost: www.ajiu9.com\nConnection: keep-alive\nCache-Control: max-age=0\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9\nIf-None-Match: W/&quot;5ba9f717-234&quot;\nIf-Modified-Since: Tue, 25 Sep 2018 08:51:35 GMT\n</code></pre>\n<ul>\n<li>\n<p>第一部分：请求行，用来说明请求类型,要访问的资源以及所使用协议和版本。</p>\n</li>\n<li>\n<p>第二部分：求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息。</p>\n</li>\n<li>\n<p>第三部分：空行，请求头部后面的空行是必须的。</p>\n</li>\n<li>\n<p>第四部分：请求数据也叫主体，可以添加任意的其他数据（这个例子的请求数据为空）。</p>\n</li>\n</ul>\n<h5>响应报文示例</h5>\n<pre><code>HTTP/1.1 304 Not Modified\nDate: Tue, 25 Sep 2018 08:53:14 GMT\nVia: 1.1 varnish\nCache-Control: max-age=600\nETag: W/&quot;5ba9f717-234&quot;\nExpires: Tue, 25 Sep 2018 09:03:04 GMT\nAge: 10\nConnection: keep-alive\nX-Served-By: cache-tyo19932-TYO\nX-Cache: HIT\nX-Cache-Hits: 1\nX-Timer: S1537865594.266742,VS0,VE0\nVary: Accept-Encoding\nX-Fastly-Request-ID: d33e186dc5ff53c01d8128c32ff8a0f1092c9832\n</code></pre>\n<ul>\n<li>\n<p>第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。</p>\n</li>\n<li>\n<p>第二部分：消息报头，用来说明客户端要使用的一些附加信息</p>\n</li>\n<li>\n<p>第三部分：空行，消息报头后面的空行是必须的。</p>\n</li>\n<li>\n<p>第四部分：响应正文，服务器返回给客户端的文本信息。</p>\n</li>\n</ul>\n<h4>http请求方法</h4>\n<ul>\n<li>get ———— 获取资源</li>\n<li>post ———— 传输资源</li>\n<li>put ———— 更新资源</li>\n<li>delete ———— 删除资源</li>\n<li>head ———— 获得报文首部</li>\n</ul>\n<h4>get和post的区别</h4>\n<ul>\n<li>\n<p><code>get在浏览器回退是无害的，而post会再次提交请求</code></p>\n</li>\n<li>\n<p><code>get请求会被浏览器主动缓存，而post不会，除非手动设置</code></p>\n</li>\n<li>\n<p><code>get请求参数会被完整保留在浏览器的历史记录里，而post中的参数不会被保留</code></p>\n</li>\n<li>\n<p><code>get请求中传送的参数是有长度限制的（一般是2kb，不同浏览器不一样），post没有长度限制</code></p>\n</li>\n<li>\n<p><code>get参数通过URL传递，post放在Request body中</code></p>\n</li>\n<li>\n<p>get产生的URL地址可以被收藏，而get不可以</p>\n</li>\n<li>\n<p>get请求只能进行url编码，而post支持多种编码方式</p>\n</li>\n<li>\n<p>对参数的数据类型，get只接受ASCLL字符，而post没有限制</p>\n</li>\n<li>\n<p>get比post更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息</p>\n</li>\n</ul>\n<h4>http状态码</h4>\n<ul>\n<li>\n<p>1xx：指示信息 ——表示请求已接收，继续处理</p>\n</li>\n<li>\n<p>2xx：成功——表示请求已被成功接收</p>\n</li>\n<li>\n<p>3xx：重定向——要完成请求必须进行更进一步的操作</p>\n</li>\n<li>\n<p>4xx：客户端错误——请求有语法错误或请求无法实现</p>\n</li>\n<li>\n<p>5xx：服务端错误——服务器未能实现合法的请求</p>\n</li>\n<li>\n<p>200 OK：客户端请求成功</p>\n</li>\n<li>\n<p>206 Partial Content: 客户发送了一个带Range头的GET请求，服务器完成了它</p>\n</li>\n<li>\n<p>301 Move Parmanently：所请求的页面已经转移到新的url</p>\n</li>\n<li>\n<p>302 Found：所请求的页面已经临时转移至新的url</p>\n</li>\n<li>\n<p>304 Not Modified：客户端有缓冲的文档并发出了一个条件性的请求，服务器告诉客户，原来缓冲的文档还可以继续使用</p>\n</li>\n<li>\n<p>400 Bad Request：客户端请求有语法错误，不能被服务端所理解</p>\n</li>\n<li>\n<p>401 Unauthorized：请求未经授权,这个状态代码必须和WWW-Authenticate报头域一起使用</p>\n</li>\n<li>\n<p>403 Forboidden：对被请求页面的访问被禁止</p>\n</li>\n<li>\n<p>404 NOt Found：请求资源不存在</p>\n</li>\n<li>\n<p>500 Internal Server Error：服务器发送不可预期的错误原来缓冲文档还可以继续使用</p>\n</li>\n<li>\n<p>503 Server Unavailable：请求未完成，服务器临时过载或当机，一段时间后可能恢复正常</p>\n</li>\n</ul>\n<h4>持久连接</h4>\n<p>HTTP协议采用“请求-应答”模式，当使用普通模式，即非Keep-Alive模式时，每个请求/应答客户和服务器都要新建一个连接，完成 之后立即断开连接（HTTP协议为无连接的协议）；<br>\n当使用Keep-Alive模式（又称持久连接、连接重用）时，Keep-Alive功能使客户端到服 务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。</p>\n<p>http 1.0中默认是关闭的，需要在http头加入”Connection: Keep-Alive”，才能启用Keep-Alive；<br>\nhttp 1.1中默认启用Keep-Alive，如果加入”Connection: close “，才关闭。</p>\n<p>目前大部分浏览器都是用http1.1协议，也就是说默认都会发起Keep-Alive的连接请求了，所以是否能完成一个完整的Keep-Alive连接就看服务器设置情况。</p>\n<h4>管线化</h4>\n<ul>\n<li>\n<p>1.在使用持久连接的情况下，某个连接上消息的传递类似于，请求一次响应一次并且不断开<br>\n请求1-&gt; 响应1-&gt;请求2-&gt;响应2-&gt;请求3-&gt;响应3</p>\n</li>\n<li>\n<p>2.管线化通道是持久建立的，把所有请求打包一次传输，所有响应打包一次传输<br>\n请求1-&gt;请求2-&gt;请求3-&gt;响应1-&gt;响应2-&gt;响应3</p>\n</li>\n</ul>\n<h4>管线化特点</h4>\n<ul>\n<li>\n<p>管线化机制通过持久连接完成，仅HTTP/1.1支持此技术</p>\n</li>\n<li>\n<p>只有get和head请求可以进行管线化，而post则有所限制</p>\n</li>\n<li>\n<p>初次创建连接是不应启动管线机制，因为对方(服务器)不一定支持HTTP/1.1版本的协议</p>\n</li>\n<li>\n<p>管线化不会影响响应到来的顺序，如上面的例子所示，响应返还的顺序并未改变</p>\n</li>\n<li>\n<p>HTTP/1.1要求服务器端支持管线化，但并不要求服务器端也对响应进行管线化处理，只是要求对于管线化的请求不失败即可</p>\n</li>\n<li>\n<p>由于上面提到的服务器端问题，开启管线化很可能并不会带来大幅度的性能提升，而且很多服务器端和代理程序对管线化的支持并不好，因此现代浏览器如Chrome和Firefox默认并未开启管线化支持</p>\n</li>\n</ul>\n",
            "url": "https://ajiu9.cn/posts/http-protocol-class",
            "title": "HTTP协议类",
            "date_modified": "2018-09-25T00:00:00.000Z",
            "author": {
                "name": "Ajiu9",
                "url": "https://ajiu9.cn"
            }
        },
        {
            "content_html": "<p>CMAScript的变量可能包含两种不同数据类型的值：基本类型值和引用类型值。基本类型的值是简单的数据段，引用类型的值是多个值构成的对象。</p>\n<p>把一个值赋值给变量时，解析器首先确定这个值是基本类型的值还是引用类型的值。基本数据类型有5种：Undefined、Null、Boolean、Number、String。这5种基本数据类型是按值访问的，因为可以操作保存在变量中的实际值。引用类型的值是按照引用访问的，因为javaScript不允许访问内存中的位置，不能直接操作对象的内存空间。（为对象添加属性操作的是实际对象）</p>\n<p><strong>动态属性</strong></p>\n<p>首先我们来定义一个引用类型的值：</p>\n<p><img src=\"https://static.ajiu9.cn/images/202403102118517qwJD2.png\" alt=\"图片\"></p>\n<p>以上代码创建了一个对象并将其保存在person变量中，然后为变量添加了一个名为name的属性，并将字符串“江月夜”赋给了这个属性。之后通过函数alert（）访问了这个新属性。如果对象不被销毁或者这个属性不被删除，则各属性将一直存在。</p>\n<p>但是，不能给基本类型的值添加属性（不会导致错误）</p>\n<p><img src=\"https://static.ajiu9.cn/images/20240310211733UOVZPP.png\" alt=\"图片\"></p>\n<p><strong>赋值变量值</strong></p>\n<p>除了保存方式不一样，变量复制也有区别。</p>\n<p>基本类型复制后的俩个变量彼此独立，此后，这俩个变量可以参与任何操作而不会互相影响。</p>\n<p>引用类型的变量复制其实是一个指针，而这个指针指向存储在堆中的一个对象。复制结束后，俩个对象实际上引用同一个对象。改变其中一个变量，就会影响另一个变量。</p>\n<p><img src=\"https://static.ajiu9.cn/images/20240310211540NpJlfl.png\" alt=\"图片\"></p>\n<p><strong>传递参数</strong></p>\n<p>函数的参数是按值传递的，基本类型的传递会把值复制给arguments对象中的一个元素（局部变量），引用类型的传递会把这个值在内存中的地址复制给一个局部变量，所以会反应在函数的外部。</p>\n",
            "url": "https://ajiu9.cn/posts/js-type-about-type-and-Reference",
            "title": "JavaScript基本类型和引用类型",
            "date_modified": "2017-12-01T00:00:00.000Z",
            "author": {
                "name": "Ajiu9",
                "url": "https://ajiu9.cn"
            }
        }
    ]
}